@startuml error-handling-sequence
!theme plain
title Error Handling Flow - Railway-Oriented Programming
caption Demonstrates functional error handling with Either type and error propagation patterns

skinparam participant {
    BackgroundColor<<Actor>> #F0F8FF
    BackgroundColor<<Presentation>> #B4FFE5
    BackgroundColor<<Application>> #B4E5FF
    BackgroundColor<<Domain>> #FFE5B4
    BackgroundColor<<Infrastructure>> #E5B4FF
    BorderColor Black
}

skinparam note {
    BackgroundColor #FFE4E1
    BorderColor #8B0000
}

actor "User" as User <<Actor>>
participant "PureAsyncCli" as CLI <<Presentation>>
participant "CreateGreetingUseCase" as UseCase <<Application>>
participant "PersonName" as Name <<Domain>>
participant "DefaultGreetingService" as Service <<Infrastructure>>
participant "ConsoleOutputAdapter" as Output <<Infrastructure>>
participant "ConsoleErrorOutputAdapter" as ErrorOutput <<Infrastructure>>

== Validation Error Flow ==

User -> CLI: Invalid name "123!@#"
activate CLI

CLI -> CLI: Create command
note right of CLI: CreateGreetingCommand\n(name="123!@#")

CLI -> UseCase: execute(command)
activate UseCase

UseCase -> Name: of("123!@#")
activate Name

Name -> Name: Validate against business rules
note right of Name
    Validation fails:
    • Contains numbers: "123"
    • Contains symbols: "!@#"
    • Pattern: ^[a-zA-Z\s'-]+$
end note

Name --> UseCase: Either.Left(\nDomainError.ValidationError(\n  field="name",\n  message="Name can only contain letters, spaces, hyphens, and apostrophes"\n))
deactivate Name

UseCase -> UseCase: Transform domain error
note right of UseCase: ApplicationError.DomainErrorWrapper(\n  domainError=ValidationError(...)\n)

UseCase -> ErrorOutput: sendError("Validation failed: Invalid name format")
activate ErrorOutput
ErrorOutput -> ErrorOutput: Write to System.err
ErrorOutput --> UseCase: Either.Right(Unit)
deactivate ErrorOutput

UseCase --> CLI: Either.Left(\nApplicationError.DomainErrorWrapper)
deactivate UseCase

CLI -> CLI: Extract user message
note right of CLI: domainError.userMessage:\n"Name can only contain letters, spaces,\nhyphens, and apostrophes"

CLI --> User: Error: Invalid input: Name can only contain letters, spaces, hyphens, and apostrophes
deactivate CLI

== Business Rule Violation ==

User -> CLI: Empty name ""
activate CLI

CLI -> UseCase: execute(command)
activate UseCase

UseCase -> Name: of("")
activate Name

Name -> Name: Check if blank
note right of Name: isEmpty() || isBlank() → true

Name --> UseCase: Either.Left(\nDomainError.ValidationError(\n  field="name",\n  message="Name cannot be blank"\n))
deactivate Name

UseCase -> ErrorOutput: sendError("Business rule violation: Name cannot be blank")
activate ErrorOutput
ErrorOutput --> UseCase: Either.Right(Unit)
deactivate ErrorOutput

UseCase --> CLI: Either.Left(\nApplicationError.DomainErrorWrapper)
deactivate UseCase

CLI --> User: Error: Invalid input: Name cannot be blank
deactivate CLI

== Infrastructure Failure ==

User -> CLI: Valid name "Alice"
activate CLI

CLI -> UseCase: execute(command)
activate UseCase

UseCase -> Name: of("Alice")
activate Name
Name --> UseCase: Either.Right(PersonName("Alice"))
deactivate Name

UseCase -> Service: createGreeting(personName, format)
activate Service
Service --> UseCase: Either.Right("Hello World from Alice!")
deactivate Service

UseCase -> Output: send("Hello World from Alice!")
activate Output

Output -> Output: Attempt write to System.out
note right of Output
    Scenario: Output stream closed
    or security manager blocks access
end note

Output -> Output: Handle IOException
note right of Output: Transform to ApplicationError:\nOutputError(\n  "Failed to write greeting to console"\n)

Output --> UseCase: Either.Left(\nApplicationError.OutputError)
deactivate Output

UseCase -> ErrorOutput: sendError("Failed to deliver greeting: Console output unavailable")
activate ErrorOutput
ErrorOutput --> UseCase: Either.Right(Unit)
deactivate ErrorOutput

UseCase --> CLI: Either.Left(\nApplicationError.OutputError)
deactivate UseCase

CLI --> User: Error: Failed to deliver greeting: Console output unavailable
deactivate CLI

== Successful Flow (Happy Path) ==

User -> CLI: Valid name "Bob"
activate CLI

CLI -> UseCase: execute(command)
activate UseCase

UseCase -> Name: of("Bob")
activate Name
Name --> UseCase: Either.Right(PersonName("Bob"))
deactivate Name

UseCase -> Service: createGreeting(personName, format)
activate Service
Service --> UseCase: Either.Right("Hello World from Bob!")
deactivate Service

UseCase -> Output: send("Hello World from Bob!")
activate Output
Output -> Output: println("Hello World from Bob!")
Output --> UseCase: Either.Right(Unit)
deactivate Output

UseCase --> CLI: Either.Right(\nGreetingResult(\n  greeting="Hello World from Bob!",\n  personName=PersonName("Bob"),\n  timestamp=Instant.now()\n))
deactivate UseCase

CLI --> User: Hello World from Bob!
note right of CLI: Success! No error handling needed

deactivate CLI

== Error Type Hierarchy ==

note over UseCase, ErrorOutput
    <b>Error Propagation Pattern:</b>
    
    <b>Domain Layer:</b>
    • DomainError.ValidationError
    • DomainError.BusinessRuleViolation
    • DomainError.NotFound
    
    <b>Application Layer:</b>
    • ApplicationError.DomainErrorWrapper
    • ApplicationError.OutputError
    • ApplicationError.UnexpectedError
    
    <b>Presentation Layer:</b>
    • Extract user-friendly messages
    • Log technical details
    • Return appropriate exit codes
end note

== Railway-Oriented Programming ==

note over CLI, Service
    <b>Either<Error, Success> Pattern:</b>
    • Operations either succeed with a value or fail with an error
    • Errors are typed and carry context
    • No exceptions thrown for business logic failures
    • Composable error handling with flatMap/fold
    • Clear separation between expected and unexpected errors
end note

@enduml