@startuml architecture-overview
!theme plain
title Hybrid Architecture Template - System Overview
caption A modern Kotlin architecture combining Hexagonal, Clean, and Vertical Slice patterns

skinparam componentStyle rectangle
skinparam component {
    BackgroundColor<<Domain>> #FFE5B4
    BackgroundColor<<Application>> #B4E5FF
    BackgroundColor<<Infrastructure>> #E5B4FF
    BackgroundColor<<Presentation>> #B4FFE5
    BackgroundColor<<Bootstrap>> #FFCCCC
    BorderColor Black
    FontSize 14
    FontStyle bold
}

skinparam note {
    BackgroundColor #FFFFCC
    BorderColor #666666
}

package "Bootstrap Module" <<Bootstrap>> {
    [AsyncEntryPoint] as entry
    [CompositionRoot] as root
    [SecureArgParser] as parser
    [AppConfig] as config
    
    entry --> root : initializes
    entry --> parser : parses args
    parser --> config : creates
}

package "Presentation Layer" <<Presentation>> {
    [PureAsyncCli] as cli
    [AsyncCliRunner] as runner
    [CliFactory] as factory
    [PresentationConfig] as pconfig
    
    factory --> cli : creates
    cli --> runner : uses
    cli --> pconfig : configured by
}

package "Application Layer" <<Application>> {
    package "Ports" {
        interface "CreateGreetingInputPort" as input
        interface "OutputPort" as output
        interface "ErrorOutputPort" as error
    }
    
    package "Use Cases" {
        [CreateGreetingUseCase] as usecase
        [CreateBatchGreetingsUseCase] as batch
    }
    
    package "DTOs" {
        [CreateGreetingCommand] as cmd
        [GreetingResult] as result
        [ApplicationError] as apperror
    }
    
    usecase ..|> input : implements
    usecase --> output : sends messages
    usecase --> error : sends errors
    batch --> usecase : delegates to
}

package "Domain Layer" <<Domain>> {
    package "Core Business" {
        [PersonName] as name
        [GreetingFormat] as format
        [DomainError] as domerror
    }
    
    package "Services" {
        interface "GreetingService" as service
        [GreetingPolicy] as policy
    }
    
    service --> name : validates
    service --> format : uses
    policy --> format : determines
}

package "Infrastructure Layer" <<Infrastructure>> {
    package "Service Implementations" {
        [DefaultGreetingService] as impl
    }
    
    package "Output Adapters" {
        [ConsoleOutputAdapter] as console
        [ConsoleErrorOutputAdapter] as cerror
        [FileOutputAdapter] as file
        [BufferedFileOutputAdapter] as buffer
        [CompositeOutputAdapter] as composite
    }
    
    impl ..|> service : implements
    console ..|> output : implements
    cerror ..|> error : implements
    file ..|> output : implements
    buffer ..|> output : implements
    composite ..|> output : implements
}

' Main dependencies
cli --> input : executes
usecase --> service : uses
usecase --> cmd : receives
usecase --> result : returns

' Bootstrap wiring (dashed lines for runtime creation)
root ..> impl : creates
root ..> console : creates
root ..> cerror : creates
root ..> usecase : creates
root ..> factory : uses

' Notes
note top : Dependencies flow inward toward Domain Layer\nBootstrap is the only module that knows all concrete types

note right of "Domain Layer" : Pure business logic\nNo framework dependencies\nStable core of the system

note left of "Application Layer" : Orchestrates business logic\nDefines boundaries (ports)\nHandles cross-cutting concerns

note bottom of "Infrastructure Layer" : Technical implementations\nExternal system integrations\nAll I/O operations

@enduml