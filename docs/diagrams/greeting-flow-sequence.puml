@startuml greeting-flow-sequence
!theme plain
title Greeting Creation Flow - Async Sequence Diagram
caption Shows the complete flow from CLI input to greeting output using modern async architecture

skinparam participant {
    BackgroundColor<<Actor>> #F0F8FF
    BackgroundColor<<Bootstrap>> #FFCCCC
    BackgroundColor<<Presentation>> #B4FFE5
    BackgroundColor<<Application>> #B4E5FF
    BackgroundColor<<Domain>> #FFE5B4
    BackgroundColor<<Infrastructure>> #E5B4FF
    BorderColor Black
}

actor "User" as User <<Actor>>
participant "AsyncEntryPoint" as Entry <<Bootstrap>>
participant "SecureArgParser" as Parser <<Bootstrap>>
participant "CompositionRoot" as Root <<Bootstrap>>
participant "PureAsyncCli" as CLI <<Presentation>>
participant "CreateGreetingUseCase" as UseCase <<Application>>
participant "PersonName" as Name <<Domain>>
participant "DefaultGreetingService" as Service <<Infrastructure>>
participant "GreetingPolicy" as Policy <<Domain>>
participant "ConsoleOutputAdapter" as Output <<Infrastructure>>
participant "ConsoleErrorOutputAdapter" as ErrorOutput <<Infrastructure>>

== Startup and Signal Handling ==

User -> Entry: Execute with args ["Alice"]
activate Entry
note right of Entry: Installs signal handlers\nfor graceful shutdown

Entry -> Parser: parseArgs(args)
activate Parser
Parser -> Parser: Validate arguments\nSecurity checks
Parser --> Entry: AppConfig(name="Alice")
deactivate Parser

Entry -> Root: buildAndRunAsync(config)
activate Root

Root -> Root: Wire dependencies
note right of Root
    Creates:
    • DefaultGreetingService
    • ConsoleOutputAdapter
    • ConsoleErrorOutputAdapter
    • CreateGreetingUseCase
    • PureAsyncCli
end note

== Async Execution ==

Root -> CLI: runAsync()
activate CLI

CLI -> CLI: Create command object
note right of CLI: CreateGreetingCommand\n(name="Alice")

CLI -> UseCase: execute(command)
activate UseCase

UseCase -> Name: of("Alice")
activate Name
Name -> Name: Validate input
note right of Name
    Rules:
    • Not blank/empty
    • 1-50 characters
    • Letters and spaces only
    • Trim whitespace
end note

alt Valid Name
    Name --> UseCase: Either.Right(PersonName("Alice"))
    deactivate Name
    
    UseCase -> Service: createGreeting(personName, format)
    activate Service
    
    Service -> Policy: determineFormat(personName)
    activate Policy
    Policy -> Policy: Apply business rules
    note right of Policy
        Logic:
        • Anonymous → CASUAL
        • Named users → FRIENDLY
    end note
    Policy --> Service: GreetingFormat.FRIENDLY
    deactivate Policy
    
    Service -> Service: Generate greeting text
    note right of Service: "Hello World from Alice!"
    
    Service --> UseCase: Either.Right("Hello World from Alice!")
    deactivate Service
    
    UseCase -> Output: send("Hello World from Alice!")
    activate Output
    Output -> Output: Validate message
    Output -> Output: Write to System.out
    Output --> UseCase: Either.Right(Unit)
    deactivate Output
    
    UseCase --> CLI: Either.Right(GreetingResult)
    deactivate UseCase
    
    CLI -> CLI: Log success (if verbose)
    CLI --> Root: 0 (success)

else Invalid Name
    Name --> UseCase: Either.Left(ValidationError)
    deactivate Name
    
    UseCase -> ErrorOutput: sendError("Invalid name: ...")
    activate ErrorOutput
    ErrorOutput -> ErrorOutput: Write to System.err
    ErrorOutput --> UseCase: Either.Right(Unit)
    deactivate ErrorOutput
    
    UseCase --> CLI: Either.Left(ApplicationError)
    deactivate UseCase
    
    CLI -> CLI: Handle error gracefully
    CLI --> Root: 1 (error)
end

deactivate CLI
Root --> Entry: Exit code
deactivate Root

Entry -> Entry: Cleanup and shutdown
Entry --> User: Process exit
deactivate Entry

== Error Propagation Pattern ==

note over UseCase, ErrorOutput
    <b>Functional Error Handling:</b>
    • All operations return Either<Error, Success>
    • Errors bubble up through layers
    • No exceptions for business logic failures
    • Separate error output channel
end note

== Coroutine Context ==

note over CLI, Service
    <b>Structured Concurrency:</b>
    • All async operations in coroutineScope
    • Cancellation support throughout
    • Proper resource cleanup
    • Exception handling with CoroutineExceptionHandler
end note

@enduml